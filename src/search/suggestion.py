import streamlit as st
import pandas as pd
import numpy as np
from collections import Counter
from src.utilities.helpers import calculate_suggested_label
import os

# Directory where Parquet files are saved
PARQUET_DIR = os.path.join("data", "processed")


def app():
    st.title('Category Suggestion')
    st.write("Suggests categories based on similarity.")

    st.sidebar.title("Settings")

    # List all .parquet files in the data/processed directory
    if not os.path.exists(PARQUET_DIR):
        st.error(
            f"Directory '{PARQUET_DIR}' not found. Generate embeddings first.")
        return

    parquet_files = [f for f in os.listdir(
        PARQUET_DIR) if f.endswith(".parquet")]
    if not parquet_files:
        st.error(
            f"No Parquet files found in '{PARQUET_DIR}'. Generate embeddings first.")
        return

    # Let the user select a Parquet file
    selected_parquet = st.sidebar.selectbox(
        "Select a Parquet file to process",
        parquet_files,
        help="Choose a Parquet file generated by the Datasource app."
    )

    # Construct the full path to the selected Parquet file
    parquet_file = os.path.join(PARQUET_DIR, selected_parquet)

    n_similares = st.sidebar.slider("Number of Similar Elements", 1, 25, 5)
    similarity_threshold = st.sidebar.slider(
        "Similarity Threshold", 0.8, 1.0, 0.99)
    n_view = st.sidebar.slider("Number of Elements to Display", 1, 30, 25)
    perc_filter = st.sidebar.slider(
        "Percentage of Dataset to Evaluate", 10, 100, 30)
    label_search_button = st.sidebar.button("Generate Suggestions")

    if label_search_button:
        if not os.path.exists(parquet_file):
            st.error(
                f"File '{parquet_file}' not found. Generate embeddings first.")
            return

        df = pd.read_parquet(parquet_file)
        if 'label' not in df.columns:
            df['label'] = ""

        df = calculate_suggested_label(
            df, n_similares, similarity_threshold, perc_filter)

        st.session_state.df = df
        st.session_state.current_label_index = 0

    if 'df' in st.session_state:
        df = st.session_state.df
        if 'suggested_label' not in df.columns:
            st.error(
                "The 'suggested_label' column is missing in the DataFrame. Please ensure suggestions were generated correctly.")
            return

        distinct_labels = df['suggested_label'].dropna().unique()

        label_index = st.session_state.get('current_label_index', 0)
        next_back_cols = st.columns([1, 1, 2])
        with next_back_cols[0]:
            if st.button("BACK"):
                st.session_state.current_label_index = (
                    label_index - 1) % len(distinct_labels)
                label_index = st.session_state.current_label_index
        with next_back_cols[1]:
            if st.button("NEXT"):
                st.session_state.current_label_index = (
                    label_index + 1) % len(distinct_labels)
                label_index = st.session_state.current_label_index

        if label_index < len(distinct_labels):
            current_label = distinct_labels[label_index]
            current_elements = df[df['suggested_label']
                                  == current_label].head(n_view)

            st.header(f"Current Label: {current_label}")

            selected_similars = []
            for idx, row in current_elements.iterrows():
                col1, col2 = st.columns([7, 1])
                with col1:
                    if st.checkbox(f"{row['combined_text'][0:600]}", key=idx, value=True):
                        selected_similars.append(idx)
                with col2:
                    st.write(f"Label: {row['label']}")

            if st.button("LABEL"):
                for idx in selected_similars:
                    df.at[idx, 'label'] = current_label

                st.session_state.df = df
                try:
                    df.to_parquet(parquet_file, index=False)
                    st.success(
                        "Elements labeled successfully and file updated!")
                except Exception as e:
                    st.error(f"Error saving file: {e}")
        else:
            st.info("All suggestions have been reviewed.")


if __name__ == "__main__":
    app()
